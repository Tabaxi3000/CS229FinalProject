% MCTS Implementation Section for CS229 Project

\subsection{Monte Carlo Tree Search Implementation}

Our Gin Rummy agent employs a specialized Monte Carlo Tree Search (MCTS) algorithm adapted for imperfect information card games. Unlike traditional MCTS implementations for perfect information games like Chess or Go, our approach must handle partial observability and the inherent uncertainty in card games.

\subsubsection{Tree Structure and State Representation}

Each node in our search tree represents a game state encoded as a tuple $(H, D, V)$, where $H$ is a 4Ã—13 binary matrix representing the player's hand, $D$ captures the discard pile history, and $V$ is a binary mask of valid actions. This compact representation allows efficient state manipulation while preserving all necessary game information.

The action space encompasses 110 possible moves: 52 for discarding cards, 52 for drawing specific cards (when visible in the discard pile), and 6 special actions including drawing from the stock pile, knocking, and going gin.

\subsubsection{Selection Strategy}

During node selection, we use a modified Upper Confidence Bound (UCB1) formula that balances exploration and exploitation:

\[
UCT(s,a) = Q(s,a) + c\sqrt{\frac{\ln N(s)}{N(s,a)}}
\]

Here, $Q(s,a)$ represents the expected reward for taking action $a$ in state $s$, while $N(s)$ and $N(s,a)$ track visit counts for the state and state-action pair respectively. We set the exploration constant $c$ to $\sqrt{2}$, though this value can be tuned based on the desired exploration-exploitation trade-off.

\subsubsection{Performance Optimizations}

To manage the computational complexity of Gin Rummy's large branching factor, we implement several key optimizations:

\begin{enumerate}
\item Progressive widening limits child node expansion based on visit counts:
\[
k(n) = \left\lfloor c_1 n^{c_2} \right\rfloor
\]
where $n$ is the parent node visit count and $(c_1, c_2) = (2, 0.5)$.

\item Action pruning eliminates invalid moves using the valid actions mask, significantly reducing the effective branching factor.

\item Parallel tree search with virtual loss enables efficient multi-core utilization while maintaining search integrity.
\end{enumerate}

These optimizations allow our agent to perform deep tree search within reasonable time constraints, typically exploring 10,000-50,000 nodes per second on modern hardware. 